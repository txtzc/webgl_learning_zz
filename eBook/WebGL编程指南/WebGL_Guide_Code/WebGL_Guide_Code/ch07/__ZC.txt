1、
矩阵操作类：../lib/cuon-matrix.js
矩阵初始坐标：Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]);
          即  [1,0,0,0,
	       0,1,0,0,
	       0,0,1,0,
	       0,0,0,1]


Pdf.P256
          <"从视点看上去"的旋转后顶点坐标> = <视图矩阵> × <旋转矩阵> × <原始顶点坐标>
  式7.1                                      <视图矩阵> × <模型矩阵> × <原始顶点坐标>

  ZC: (uniform)视图矩阵 --> eye(视点[看着哪个点])       (这个是点坐标)
                   at(观察点[眼睛在哪个点])    (这个是点坐标)
                   up(上方向[头顶对着的方向])  (这个是有3个分量的矢量 Pdf.P250)

  ZC: (uniform)模型矩阵/旋转矩阵 --> 物体自己旋转一定的角度的矩阵 (问题: 旋转&平移&缩放，都是用这个矩阵吗 ??)

Pdf.P258
  为了减少开销，js中计算好 <视图矩阵> × <模型矩阵>，再传入顶点着色器
  <模型视图矩阵> = <视图矩阵> × <模型矩阵>

  式7.1 --> 式7.2: <"从视点看上去"的旋转后顶点坐标> = <模型视图矩阵> × <原始顶点坐标>

  ZC: 模型视图矩阵 (uniform)

  0703_LookAtRotatedTriangles_mvMatrix.js 中
    var modelViewMatrix = viewMatrix.multiply(modelMatrix);
    ZC: 注意顺序：          视图矩阵.multiply(模型矩阵);

Pdf.P259
  计算 模型视图矩阵 的2种js方式:
    (1) 声明2个 Matrix4，视图 和 模型 --> 它们2个相乘
    (2) 声明1个 Matrix4(视图矩阵)，然后 旋转它

Pdf.P260
  0704_LookAtTrianglesWithKeys.html  利用键盘改变视点(位置)

  ZC: 键盘按 ↑↓时，效果有点不对，应该是 后面说的 显示范围的问题？？
  ZC:	应该是的，Z+ 是远离屏幕，Z- 是往屏幕里面去

  类似全局变量的 u_ViewMatrix和viewMatrix + 清空canvas + 重新绘制三角形

Pdf.P264
  可视空间:   正射投影 --> 盒状可视空间
              透视投影

    正射投影 --> 盒状可视空间: (A) 近裁剪面, 4个顶点: (right, top, near)
                                                      (left, top, near)
                                                      (left, bottom, near)
                                                      (right, bottom, near)

                               (B) 远裁剪面, 4个顶点: (right, top, far)
                                                      (left, top, far)
                                                      (left, bottom, far)
                                                      (right, bottom, far)

       ZC: 结合下面的内容和代码，这里写错了。应该是 left/right/top/bottom/near/far 在数值上, 该是正值就正值 该是负值就负值。


  P.265 <canvas>上显示的是可视空间中物体在 近裁剪面 上的投影。
        如果 裁剪面的宽高比 和 <canvas> 不一样，那么画面就会按照 <canvas>的宽高比进行压缩，物体会被扭曲。ZC: 这里 裁剪面，是指 近?远?盒状空间?
	近&远裁剪面之间的盒状空间就是可视空间，只有在此空间内的物体会被显示出来。

  P.268 ZC: 实验下来，貌似 不合理: left/right/top/bottom 是 该正值就正值 该负值就负值，但是 near/far却是正值 且表示屏幕往里的深度 且 far>near。
        ZC: 按照我的理解 来修改 本例子，使得 near/far 也是按照 Z轴的方向 该正值就正值 该负值就负值。
	ZC:   主要得修改 Matrix4.prototype.setOrtho(...) + 观察 如果我的三角形若是在Z+位置的话 是否显示正常 ? ? ?
	ZC:       0705_OrthoView__ZC.html & 0705_OrthoView__ZC.js & 函数Matrix4.prototype.setOrtho_zc(...)


Pdf.P273 补上缺掉的角 (0706_LookAtTrianglesWithKeys_ViewVolume.html/js)
    “这是由于远裁剪面国语接近视点所致，...”

  式7.3   <正射投影矩阵> × <视图矩阵> × <顶点坐标>

  P274 “投影矩阵 与 顶点 无关，所以 它是 uniform变量。”
    ZC: 这怎么理解？与 顶点无关 --> uniform变量; 与顶点有关 --> attribute变量 ? ? ?
    ZC: 我发现 往左/右 到达一定的距离，还是会有缺角的，把远裁剪面的距离由2.0拉得更远，能够不缺角。这个缺角 我觉得效果就像是 投影的盒状空间 也经过了空间坐标转换。


2、
  2.1、一些测试的数据 / 常量之类的
  	setLookAt(0.0, 0.0, 0.0,
	          0, 0, -15,// // -5, -15, -150 都一样
		  0, 1, 0);
           [1, 0, 0, 0,
            0, 1, 0, 0,
            0, 0, 1, 0,
            0, 0, 0, 1]

	setLookAt(0.0, 0.0, 1.0,
	          0, 0, -5,// -5, -15, -150 都一样
		    0, 1, 0);
           [1, 0, 0, 0,
            0, 1, 0, 0,
            0, 0, 1, 0,
            0, 0,-1, 1]

	setLookAt(1.0, 0.0, 1.0, 
	          0, 0, -150,// 这里，-5, -15, -150 就完全不一样了
		  0, 1, 0);
           [0.9999780654907227, 0, 0.0066223712638020515, 0,
            0, 1, 0, 0
            -0.0066223712638020515, 0, 0.9999780654907227, 0,
            -0.9933556914329529, 0, -1.0066003799438477, 1]
	setLookAt(-1.0, 0.0, 1.0,
	           0, 0, -150,// 这里，-5, -15, -150 就完全不一样了
		   0, 1, 0);
           [0.9999780654907227, 0, -0.0066223712638020515, 0,
            0, 1, 0, 0
            0.0066223712638020515, 0, 0.9999780654907227, 0,
            0.9933556914329529, 0, -1.0066003799438477, 1]

	//      ******      ******      ******

	setOrtho(-1.0, 1.0, -1.0, 1.0, 0.0, 4.0);
           [1, 0, 0,  0,
            0, 1, 0,  0,
            0, 0,-0.5,0,
            0, 0,-1,  1]
	setOrtho(-1.0, 1.0, -1.0, 1.0, 0.0, 2.0);
           [1, 0, 0, 0,
            0, 1, 0, 0,
            0, 0,-1, 0,
            0, 0,-1, 1]
	setOrtho(-1.0, 1.0, -1.0, 1.0, 0.0, 1.0);
           [1, 0, 0, 0,
            0, 1, 0, 0,
            0, 0,-2, 0,
            0, 0,-1, 1]
	

  2.2、我归纳的理解：
    (1) 默认的显卡显示的区域范围: X/Y/Z轴 都是 [-1, 1]。任何点的坐标，只要超出了这个范围，就无法显示了。
      我们做的 setLookAt(...), setOrtho(...)等操作，都是通过坐标转换，将图形的坐标平移/缩放/翻转/旋转到合适的大小/位置，便于显示观察，然后通过显卡的2D显示 让眼睛以为是3D的图形.

    PS: 看"/lib/cuon-matrix.js"中的源码: Matrix4_A.multiply(Matrix4_B) 其实就是 矩阵乘法 Matrix4_B × Matrix4_A (注意这里的顺序)
                                           (这个函数的结果会将乘法结果放在Matrix4_A中，导致Matrix4_A产生变化)
                                           (我改了一个更无脑的矩阵乘法函数，不影响被乘数和乘数[Matrix4_A & Matrix4_B], 返回新的Matrix4)
                                         Matrix4_A.multiplyVector4(Vector4_C) 其实就是 向量×矩阵 Vector4_C × Matrix4_A

    (2) 0701_LookAtTriangles_ZC.html  &  0701_LookAtTriangles_ZC.js
      以蓝色三角形左下角为例: (-0.5, -0.5, 0.0)
        (2.1) 不设置 setLookAt(...) 和 setOrtho(...), 它就是在 可视区域范围内
	(2.2) 仅"setLookAt(0.0, 0.0, 0.0, 0, 0, -15, 0, 1, 0);", 可以看到变化矩阵(看上面的数据)实际就是 没有变化。
	  ∴ 原来位置什么样，最终的位置还是上面样。
	  PS: 和我一开始的理解有所冲突: 一开始觉得 眼睛从(0,0,0)看向(0,0,-1), 那Z>0的三角形，应该看不到才是啊，为什么实际上能看到呢?? 
	      理解了变换原理+看到变换矩阵的值之后, 明白了, 原来位置没变, 还在可视范围内, ∴ 网页上能看到该三角形。
	 (2.2.1) 仅"setLookAt(0.0, 0.0, 1.0, 0, 0, -15, 0, 1, 0);" 看到变换矩阵有所不同
	  (-0.5, -0.5, 0.0) 经过转换变成了 (-0.5,-0.5,-1)
	  (-0.5, -0.5, 0.8) 经过转换变成了 (-0.5,-0.5,-0.2)
	  (-0.5, -0.5, -0.4)经过转换变成了 (-0.5,-0.5,-1.4): 原本看得见的三角形，现在反而看不见了... 这就不对了... 需要配合setOrtho(...)再把它弄回来...
	  ZC: 仅是Z轴坐标变化了, 都往Z-方向平移了
	 (2.2.2) 上面都是沿着Z轴往Z-方向(屏幕里面) 直的看, 如果是写的看，就要各个轴坐标都计算了, 比较复杂, 暂时 以后再理解...

	(2.3) 仅"setOrtho(-1.0, 1.0, -1.0, 1.0, 0.0, 2.0);" 看变换矩阵, 实际也就是对Z轴坐标进行缩放+平移。
	  可以参考 setLookAt(...) 来理解, 本程序中没有实际观看效果，可以在(3)中观察
	  (-0.5, -0.5, 0.0) --> (-0.5,-0.5,-1)
	  (-0.5, -0.5, 0.8) --> (-0.5,-0.5,-1.8)
	  (-0.5, -0.5, -0.4)--> (-0.5,-0.5,-0.6)
	    可在 0706_LookAtTrianglesWithKeys_ViewVolume__ZC_B.html & 0706_LookAtTrianglesWithKeys_ViewVolume__ZC_B.js 中 看效果

	 (2.3.1) 仅"setOrtho(-1.0, 1.0, -1.0, 1.0, 0.0, 4.0);"
	  (-0.5, -0.5, 0.0) --> (-0.5,-0.5,-1)
	  (-0.5, -0.5, 0.8) --> (-0.5,-0.5,-1.4)
	    // ZC: 上面这个点坐标转换, 看变换矩阵可知, 仅加大 远裁剪面的Z坐标, 这个点始终看不见; 当远裁剪面的Z坐标<0时, 这个点又可见了...
	  (-0.5, -0.5, -0.4)--> (-0.5,-0.5,-0.8)


    (3) 0706_LookAtTrianglesWithKeys_ViewVolume__ZC_A.html & 0706_LookAtTrianglesWithKeys_ViewVolume__ZC_A.js & 
        0706_LookAtTrianglesWithKeys_ViewVolume__ZC_B.html & 0706_LookAtTrianglesWithKeys_ViewVolume__ZC_B.js

	PS: "GLSL ES"中类似“gl_Position = u_ProjMatrix * u_ViewMatrix * a_Position;”
	    实际上在手动计算的时候，应该是等式: 实际点坐标[Vector4] = 原始点坐标[Vector4] × 视图矩阵[Matrix4] × 模型(旋转)矩阵[Matrix4]

	用 js的 矩阵计算 / 矩阵&向量计算，来模拟"GLSL ES"中的坐标位置计算

	(3.1) 0706_LookAtTrianglesWithKeys_ViewVolume__ZC_A.html & 0706_LookAtTrianglesWithKeys_ViewVolume__ZC_A.js
	  这里面的点的坐标是通过 js 计算出来的, 直接可以用于运行显示
	(3.2) 0706_LookAtTrianglesWithKeys_ViewVolume__ZC_B.html & 0706_LookAtTrianglesWithKeys_ViewVolume__ZC_B.js
	  将 视点&观察点&上方向 & setOrtho(...) 设置成 和 A 中一样, 然后运行程序, 观察 A & B 网页中图片一样。
	  说明 js中模拟计算 是正确的。

	  借此, 进一步理解 书中 setLookAt(...) & setOrtho(...) 矩阵变换的含义。



3、Pdf.P275 用示例程序做实验 (ZC: 做的实验是，前面说的盒状空间的宽高比和<canvas>的宽高比不同时 会缩放 的实验)
  “..., 如果可视空间近裁剪面的宽高比与<canvas>不一致，显示出的物体就会被压缩变形。”   ZC: 这里，就是说是 近裁剪面

  说是“..., 它将近裁剪面的宽度和高度改为了原来的一半，但是保持了宽高比”，但是 实际代码 是把 近&远裁剪面的宽度和高度都改为了原来的一半...(ZC: 老是有这种说的和做的不一致问题，水平问题？翻译问题？)
  ZC: 注意书中的代码, "projMatrix.setOrtho(-0.5, 0.5, -0.5, 0.5, g_near, g_far);" X/Y的范围是变成原来的1/2, 但是 近远裁剪面的距离变成了原来的1/4

4、Pdf.P276 可视空间(透视投影)
  简单的看了下，没细看

5、Pdf.P282 共冶一炉（模型矩阵、视图矩阵和投影矩阵）
  0711_PerspectiveView_mvp.html & 0711_PerspectiveView_mvp.js
    ZC: 我看到的 技术点: 同一组点的坐标 + 偏移(模型矩阵) + 先画一批△ 再画另一批△。 我一直认为只能画一次图形 (思维僵化)。

 P284 式7.4 <"从视点看上去"的旋转后顶点坐标> = <投影矩阵> × <视图矩阵> × <旋转(模型)矩阵> × <原始顶点坐标>
                                                               ZC: 注意  <旋转(模型)矩阵>  在公式中的位置



6、Pdf.P288 正确处理对象的前后关系

 P290 隐藏面消除
  gl.enable( gl.DEPTH_TEST );// 开启 隐藏面消除
  gl.clear( gl.DEPTH_BUFFER_BIT );// 在绘制之前, 清除深度缓冲

  0721_DepthBuffer.html & 0721_DepthBuffer.js
    在绘制之前，做如下操作：
      gl.enable( gl.DEPTH_TEST );// 开启 隐藏面消除
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);// 清除 颜色&深度缓冲(上一帧画面的残留)

  ZC: 0721_DepthBuffer.html & 0721_DepthBuffer.js 中只是绘制了 固定的画面，看不到 上一帧 / 下一帧 的切换等。
  ZC: 可以试着 模仿 之前的例子那样, 通过键盘 改变视点, 然后看看 图形变化时, gl.DEPTH_TEST & gl.COLOR_BUFFER_BIT & gl.DEPTH_BUFFER_BIT 应该在什么时机进行操作。

 P293 深度冲突

  ZC: 一直没注意 “gl.clearColor(0, 0, 0, 1);// 指定清除<canvas>的背景色”

  gl.enable( gl.POLYGON_OFFSET_FILL );// 启用多边形偏移
  gl.polygonOffset(1.0, 1.0)// 在绘制之前, 指定用来计算偏移量的参数

  ZC: 同样要 观察下, 多帧切换时的 调用时机。

7、Pdf.P296 立方体
8、
9、
10、
